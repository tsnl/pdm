We want extern modules to be stored in JSON files.
- these files are the place to exhaustively re-map symbols from
  an external target into PD, which would simplify the language a lot
  by making translation explicit.
  - e.g. how do we handle returning a pointer?
- means an index is a map to either PD or external modules. Neater.

We want targets to be specified in JSON files.
- idk what goes in the target spec
- but ideally, ways to configure post-LLVM world

We want to eliminate index files entirely.
- there are 2 kinds of source node: scripts and external modules.
- scripts can import external modules and other scripts.
- external modules can import (via translation) source code in other 
  languages.

PROBLEM: how to translate `char const*` in C to `String`?
1. let the user write their own wrappers
  - suggests `extern` statements are the best solution in-module **along with** JSON files
  - so `extern'
2. define a pre-existing scheme, build libraries around it
  - e.g. `.c_str` returns a `ctype:CPtr`
  - assume all standard library modules (including 'ctype') imported in bundle 
    already for both scripts and packages
  - IDEA:
    - create a new C source unit for each module with...
    - each of the includes at the top
    - each specified declaration at a pre-determined line.
    - then we can emit this temporary source unit using only the mapped symbols in native source.
    - then we can check all source strings at once.
  - Cases:
    - for values, either function or value can be printed.
      - when we support global variables in modules,
      - need to check if typespec is 'const'
    - for types, specify `X` in `typedef <X> <DefSymName>`

`raylib.pd-extern.json`
```json
{
  "kind": "EXTERN_MODULE_IN_C",
  "input": {
    "src": [],
    "include": [
      "./raylib/include/raylib.h"
    ],
    "lib": [
      "./raylib/lib/raylib.ll"
    ]
  },
  "platform-input": {},
  "map": {
    "init_window": ["void InitWindow(int width, int height, char const* caption)"],
    "close_window": ["void CloseWindow(void)"],
    "errno": ["errno_t errno"],
    "Vector3": ["struct Vector3"]
  }
}
```

Further subdivide `.pd` into another file type: `.pdx`
- must contain a module named `entry_points` or `entry_point`
1. if `entry_points`
    - the first argument name is referenced against function names, running the specified one
      - underscores `_` may be replaced by `-` when running
      - submodule specifiers may be allowed too, i.e. `:`
2. if `entry_point`,
    - must contain a function named `main` with one of 2 signatures
3. if both, then error
4. cannot import from `.pdx` file except from a `.pdx` file.

`main.pdx`
```
import {
    raylib from "raylib.pd-extern.json"
};

mod entry_point {
    let main () Int32 = {
        raylib:init_window();
        
        # todo: render a game
        
        raylib:close_window();
    };
};
```

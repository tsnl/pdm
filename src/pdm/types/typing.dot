// https://graphs.grevian.org/example

digraph {
    splines=line;

    subgraph cluster_0 {
        label="Typer";
        bgcolor="grey";
        typer_fn [label="typer"]
    }

    subgraph cluster_1 {
        label="Types Manager";
        bgcolor="turquoise";

        assume [label="assume(Relation)", style="filled", fillcolor="grey"];
        test [label="test(Relation)", style="filled", fillcolor="grey"];

        // edges:
        typer_fn -> assume;

        subgraph cluster_1_1 {
            label="Varáµ¢";
            bgcolor="aquamarine";
            
            subgraph cluster_1_1_1 {
                label="Pass 1: Breaking common Constraints";
                constraint [label="assume(Constraint)", style="filled", fillcolor="grey"];
                common_constraints [label="common\nConstraints", shape="box", fillcolor="goldenrod", style="filled"]
                
                assumed_kind_bitset [label="assumed\nkind\nbitset", shape="box", fillcolor="goldenrod", style="filled"];
                assumed_supervars [label="assumed\nSuper-vars", shape="box", fillcolor="goldenrod", style="filled"];
                assumed_subvars [label="assumed\nSub-vars", shape="box", fillcolor="goldenrod", style="filled"];
            }

            subgraph cluster_1_1_2 {
                label="Pass 2: Breaking kind-dependent constraints";
                local_interval_set [label="local IntervalSet (basis of type space)", shape="box", fillcolor="goldenrod", style="filled"];
                check_1_2 [label="check VarKind; abort if bad bitset", style="filled", fillcolor="gray"]
                kd_constraints [label="kind-dependent\nConstraints", shape="box", fillcolor="goldenrod", style="filled"]
            }

            subgraph cluster_1_1_3 {
                label="Pass 3: Iteratively unify all ancestor supvars' IntervalSets\nand unify with own";
                solution [label="solution type", shape="box", fillcolor="yellow", style="filled"];
                check_1_3 [label="check sup/sub bitsets match"];
                global_interval_set [label="global IntervalSet (basis of type space)", shape="box", fillcolor="yellow", style="filled"];
            }

            // 1 -> 2
            constraint -> {common_constraints, kd_constraints};
            common_constraints -> {assumed_kind_bitset, assumed_subvars, assumed_supervars}

            // 2 -> 3
            {assumed_kind_bitset, kd_constraints} -> check_1_2 -> local_interval_set

            // 3 -> 4
            {local_interval_set, assumed_subvars, assumed_supervars} -> check_1_3 -> global_interval_set;
            global_interval_set -> solution
            [label="existence\nproves\ncorrectness"];
        }
        
        assume -> constraint;
        solution -> test;
    }

    subgraph cluster_2 {
        label="Backend";
        bgcolor="grey";
        templater [label="Templater"];
        emitter [label="Emitter"];
    }
    test -> {templater, emitter};
}
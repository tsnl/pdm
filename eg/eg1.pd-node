import {
    * from "./eg8.pdp";
}

mod shapes {

    Circle: {
        center Tuple[Float32, Float32],
        radius Tuple[Float32]
    };

    circumference: fn (circle Circle) Float32 {
        val tau = {
            val pi = 3.14159;
            2*pi
        };
        tau * circle.radius
    };

};

mod pixels [Type ANY] {

    Pixel: {
        r Type,
        g Type,
        b Type
    };

    add: (p Pixel, q Pixel) -> Pixel {
        r: p.r + q.r,
        g: p.g + q.g, 
        b: p.b + q.b
    };
    multiply[T Any]: (p Pixel, s T) -> Pixel {
        r: s * p.r, 
        g: s * p.g, 
        b: s * p.b
    };

};

mod image [T Any] {

    Image: {
        name String,
        size {UInt32, UInt32},
        data buffer[Pixel]::Buf
    };

    add: (lt Image, rt Image) -> Image {
        assert lt.size == rt.size;
        {
            name: fmt("({lt.name}+{rt.name})"),
            size: lt.size,
            data: map(addPixel, zip(lt.data,rt.data))
        }
    };
    multiply: (i Image[T], x U8) -> Image[T] {
        name: fmt("({x}*{i.name})"),
        size: i.size,
        data: map(i.data, lambda (p Pixel[T]) {multiply(pixel,x)})
    };

 };
 
 mod dict [Key ANY, Val ANY] {

    Dict: {
        # ...
    };

    new: () -> Dict {
        # ...
    };

    #
    # Enums
    # - untagged unions are not supported in the language by default
    # - for such operations, use `bitcast[]()` like LLVM
    #

};

mod events {

    Color = enum {
        Rgba {U8,U8,U8,U8},
        Hsva {U8,U8,U8,U8},
        Name String,
        None
    };

    Fruit = enum {
        Apple, Banana, Cherry, Durian, Fig, Grape
    };

    Key = enum {
        Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
        Tilde, N1, N2, N3, N4, N5, N6, N7, N8, N9, N0, Minus, Equals, Backspace,
        Tab, Q, W, E, R, T, Y, U, I, O, P, LeftSquareBracket, RightSquareBracket, Backslash,
        CapsLock, A, S, D, F, G, H, J, K, L, Semicolon, SingleQuote, Return,
        LeftShift, Z, X, C, V, B, N, M, Comma, Period, ForwardSlash, RightShift,
        LeftCtrl, LeftSuper, LeftAlt, RightAlt, RightSuper, RightCtrl,
        Up, Down, Left, Right
    };

    MouseButton = enum {
        Left,
        Right,
        Middle
    };

    ButtonMoveDirection = enum {
        Down,
        Up
    };

};

mod greeting {

    new_cstr = () -> CString {
        val len = 12;
        val buf = heap.alloc(Char)[len];
        set buf.(0) = 'h';
        set buf.(1) = 'e';
        set buf.(2) = 'l';
        set buf.(3) = 'l';
        set buf.(4) = 'o';
        set buf.(5) = ' ';
        set buf.(6) = 'w';
        set buf.(7) = 'o';
        set buf.(8) = 'r';
        set buf.(9) = 'l';
        set buf.(10) = 'd';
        set buf.(11) = '\0';
        {ptr=memory, len=len}
    };

};

mod Primes {

    driver = () -> Void {
        # val prime_limit = console.read_int[Int32]("Enter a number >2 until which to search for primes: ");
        val primes_until = count_primes_until(prime_limit);
        
    }

    # proposed feature: for loops:
    count_primes_until = (primes_limit Int32) -> Int32 {
        var prime_count = 1;
        
        for (i: 3 .. prime_limit step 2) {
            var i_is_prime = true;
            for (fac = 0; fac*fac < i; fac+2) {
                if (i % fac == 0) then {
                    set i_is_prime = false;
                };
            };
            if (i_is_prime) then {
                set prime_count = 1 + prime_count;
            };
        }
    };

 };
 
 mod submodules {

    mod S1 {
        hello = 0;
    };

    mod S2 [UInt UInts] {
        filter = (image Image[UInt]) -> Image {
            # ...
        };

        mod DoubleNested {
            hi = 0;
        };
    };

 };
 
# Each source file is composed of
# 1. (1) 'namespace' statement
# 2. (0 or more) 'typedef' or 'def' statements
#    - typedefs must begin with uppercase letters.
#    - all other IDs are assumed to be 'def' statements.

namespace eg1;

#
# Circles:
#

struct Circle {
    center: (F32,F32),
    radius: (F32)
};

def circumference circle:Circle = {
    let tau = {
        let pi = 3.14159;
        2*pi
    };
    tau * circle.radius
};

#
# Pixels (generics):
#

struct Pixel (T:Any) {r:T,g:T,b:T};
struct Image (T:Any) {name:String, size:(U32,U32), data:Buffer[Pixel[T]]};

def addPixel [T:Any] (p: Pixel T) (q: Pixel T) = {
    Pixel[T] (p.r+q.r, p.g+q.g, p.b+q.b)
};

def mulPixel [T:Any] (p: Pixel T) (s: T) = {
    Pixel[T] (s*p.r, s*p.g, s*p.b)
};

def addImage [T:Any] (lt: Image T) (rt: Image T) = Image[T] {
    with lt.size == rt.size;
    Image[T] {
        name: fmt "({lt.name}+{rt.name})",
        size: lt.size,
        data: map addPixel (zip lt.data rt.data)
    }
};

def mulImage [T:Any] (i: Image T) (x: U8) = Image[T] {
    let scalePixelByX = fun p => {
        mulPixel p x
    };
    Image[T] {
        name: fmt "({x}*{i.name})",
        size: i.size,
        data: map i.data scalePixelByX
    }
};

#
# Dicts (generics):
#

struct Dict (K:Any) (V:Any) = {
    # ...
};

def newDict (K:Any) (V:Any) = (Dict K V) {
    # ...
};

#
# Enums:
#

enum Color {
    rgba: (U8,U8,U8,U8),
    hsva: (U8,U8,U8,U8),
    name: String,
    none
};

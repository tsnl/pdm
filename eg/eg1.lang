# Each source file is composed of
# 1. (1) 'namespace' statement
# 2. (0 or more) 'typedef' or 'def' statements
#    - typedefs must begin with uppercase letters.
#    - all other IDs are assumed to be 'def' statements.

namespace eg1;

#
# Circles:
#

Circle = Struct {
    center: (F32,F32),
    radius: (F32)
} with {
    center.x > 0,
    center.y > 0
};

circumference circle:Circle = {
    tau = {
        pi = 3.14159;
        2*pi
    };
    return tau * circle.radius
};

#
# Pixels (generics):
#

Pixel[T] = {r:T,g:T,b:T} :: subtypes[T,Scalar];
Image[T] = {name:String, size:(U32,U32), data:Buffer[Pixel[T]]};

addPixel[T] p:Pixel[T] q:Pixel[T] = {
    Pixel[T] (p.r+q.r, p.g+q.g, p.b+q.b)
};

mulPixel[T] p:Pixel[T] s:T = {
    Pixel[T] (s*p.r, s*p.g, s*p.b)
};

addImage[T] lt:Image[T] rt:Image[T] = {
    with lt.size == rt.size;
    return Image[T] {
        name: fmt "({lt.name}+{rt.name})",
        size: lt.size,
        data: map addPixel (zip lt.data rt.data)
    }
};

mulImage[T] i:Image[T] x:U8 = {
    scalePixelByX = (
        fun p {
            mulPixel p x
        }
    );
    return Image[T] {
        name: fmt "({x}*{i.name})",
        size: i.size,
        data: map i.data scalePixelByX
    }
};

#
# Dicts (generics):
#

Dict[K,V] = {
    # ...
};

newDict[K,V] () = {
    Dict[K,V] { 
        # ...
    }
};

#
# Enums:
#

Color = Enum {
    rgba: (U8,U8,U8,U8),
    hsva: (U8,U8,U8,U8),
    name: String,
    none
};

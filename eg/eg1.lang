# Each source file is composed of
# 1. (1) 'namespace' statement
# 2. (0 or more) 'typedef' or 'def' statements
#    - typedefs must begin with uppercase letters.
#    - all other IDs are assumed to be 'def' statements.

namespace eg1;

#
# Circles:
#

Circle := {
    center: [f32,f32],
    radius: f32
};

circumference circle:Circle := {
    tau = {
        pi = 3.14159;
        2*pi
    };
    tau * circle.radius
};

#
# Pixels (generics):
#

Pixel[t] := {
    r: t,
    g: t,
    b: t
);
Image[t] := {
    name: string,
    size: [u16,u16],
    data: Buffer[Pixel[t]]
};

addPixel[t] 
    p:Pixel[t]      # the left operand to add
    q:Pixel[t]      # the right operand to add
:= {
    Pixel[t] (p.r+q.r, p.g+q.g, p.b+q.b)
};

mulPixel[t] p:Pixel[t] s:t := {
    Pixel[t] (s*p.r, s*p.g, s*p.b)
};

addImage[t] lt:Image[t] rt:Image[t] := {
    assert lt.size = rt.size;
    Image[t] {
        name: fmt "({lt.name}+{rt.name})",
        size: lt.size,
        data: map addPixel (zip lt.data rt.data)
    }
};

mulImage[t] i:Image[t] x:u8 := {
    scalePixelByX = func p -> {mulPixel p x};
    Image[t] {
        name: fmt "({x}*{i.name})",
        size: i.size,
        data: map i.data scalePixelByX
    }
};

#
# Dicts (generics):
#

Dict[k,v] := {
    # ...
};

newDict[k,v] () := {
    Dict[k,v] { 
        # ...
    }
};

#
# Enums:
#

Color = enum {
    rgba: [u8,u8,u8,u8],
    hsva: [u8,u8,u8,u8],
    name: String
};

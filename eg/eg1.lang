# Each source file is composed of (0 or more) 'typedef' or 'def' statements
# - typedefs: struct,enum,type statements
# - def: fn

#
# Circles:
#

mod circle {
    type Circle = {
        center Tuple[F32,F32],
        radius Tuple[F32]
    };

    fn circumference (circle Circle) -> F32 = {
        let tau = {
            let pi = 3.14159;
            2*pi
        };
        tau * circle.radius
    };
};

#
# Pixels (generics):
#

mod pixel {
    type Pixel [T Any] = {
        r T,
        g T,
        b T
    };
    type Image [T Any] = {
        name String,
        size Tuple[U32,U32],
        data Buffer[Pixel[T]]
    };

    fn add ![T Any] (p Pixel[T], q Pixel[T]) -> Pixel[T] = {
        r: p.r + q.r,
        g: p.g + q.g, 
        b: p.b + q.b
    };
    fn multiply ![T Any] (p Pixel[T], s T) -> Pixel[T] = {
        r: s * p.r, 
        g: s * p.g, 
        b: s * p.b
    };
};
mod image {
    fn add ![T Any] (lt Image[T], rt Image[T]) -> Image[T] = {
        assert lt.size == rt.size;
        {
            name: fmt("({lt.name}+{rt.name})"),
            size: lt.size,
            data: map(addPixel, zip(lt.data,rt.data))
        }
    };
    fn multiply ![T Any] (i Image[T], x U8) -> Image[T] = {
        name: fmt("({x}*{i.name})"),
        size: i.size,
        data: map(i.data, fn (p) {multiply(pixel,x)})
    };
};

#
# Dicts (generics):
#

mod dict {
    type Dict [K,V Any] = {
        # ...
    };

    fn new [K,V Any] () -> Dict[K,V] = {
        # ...
    };
};

#
# Enums
# - untagged unions are not supported in the language by default
# - for such operations, use `bitcast[]` like LLVM
#

mod events {
    enum Color =
    | Rgba Tuple[U8,U8,U8,U8]
    | Hsva Tuple[U8,U8,U8,U8]
    | Name String
    | None
    ;

    enum Fruit = Apple | Banana | Cherry | Durian | Fig | Grape; 

    enum Key =
    | Escape | F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10 | F11 | F12
    | Tilde  | N1 | N2 | N3 | N4 | N5 | N6 | N7 | N8 | N9 | N0 | Minus | Equals | Backspace
    | Tab       | Q | W | E | R | T | Y | U | I | O | P | LeftSquareBracket | RightSquareBracket | Backslash
    | CapsLock  | A | S | D | F | G | H | J | K | L | Semicolon | SingleQuote | Return
    | LeftShift | Z | X | C | V | B | N | M | Comma | Period | ForwardSlash | RightShift
    | LeftCtrl  | LeftMeta | LeftAlt | RightAlt | RightMeta | RightCtrl |
    | Up | Down | Left | Right
    ;

    enum MouseButton =
    | Left
    | Right
    | Middle
    ;

    enum ButtonMoveDirection =
    | Down
    | Up
    ;
};

#
# Slices and Leas:
#

mod greeting {
    
    fn new_cstr () -> CString {
        let len = 12;
        let buf = heap.alloc(Char)[len];
        set buf->(0) = 'h';
        set buf->(1) = 'e';
        set buf->(2) = 'l';
        set buf->(3) = 'l';
        set buf->(4) = 'o';
        set buf->(5) = ' ';
        set buf->(6) = 'w';
        set buf->(7) = 'o';
        set buf->(8) = 'r';
        set buf->(9) = 'l';
        set buf->(10) = 'd';
        set buf->(11) = '\0';
        {ptr=memory, len=len}
    };
};

mod heap {
    fn alloc [T Any] (len U64) -> ^&T = {
        let ptr = malloc(len * sizeof[T]);
        buffer.new(ptr,len)
    };
};

#
# Lambdas, iterators, and for:
#

mod closed {
    fn loops () -> () = {
        let prime_limit = console.read_int[I32]("Enter a number >2 until which to search for primes: ");
        let &prime_count = 1;
        
        foreach (i: 3 .. prime_limit step 2) {
            let &i_is_prime = true;
            for (fac = 0; fac*fac < i; fac+2) {
                if (i % fac == 0) then {
                    set ^i_is_prime = false;
                };
            };
            if (i_is_prime) then {
                set ^prime_count = prime_count + 1;
            };
        };
    };
};

# Each source file is composed of (0 or more) 'typedef' or 'def' statements
# - typedefs: struct,enum,type statements
# - def: 'def'

#
# Circles:
#

mod circle {
    type Circle = {
        center Tuple[F32,F32],
        radius Tuple[F32]
    };

    def circumference (circle Circle) -> {
        let tau = {
            let pi = 3.14159;
            2*pi
        };
        tau * circle.radius
    };
};

#
# Pixels (generics):
#

mod pixel {
    type Pixel [T] = {r T, g T, b T};
    type Image [T] = {name String, size Tuple[U32,U32], data Buffer[Pixel[T]]};

    def add [T] (p Pixel[T], q Pixel[T]) -> {
        Pixel[T](p.r+q.r, p.g+q.g, p.b+q.b)
    };
    def multiply [T] (p Pixel[T], s T) = {
        Pixel[T](s*p.r, s*p.g, s*p.b)
    };
};
mod image {
    def add [T] (lt Image[T], rt Image[T]) -> Image[T] {
        assert lt.size == rt.size;
        Image[T] {
            name = fmt("({lt.name}+{rt.name})"),
            size = lt.size,
            data = map(addPixel, zip(lt.data,rt.data))
        }
    };
    def multiply [T] (i Image[T], x U8) -> Image[T] {
        let scalePixelByX = fun (p) {
            pixel:multiply(p,x)
        };
        Image[T] {
            name = fmt "({x}*{i.name})",
            size = i.size,
            data = map(i.data,scalePixelByX)
        }
    };
};

#
# Dicts (generics):
#

mod dict {
    struct Dict[K,V] {
        # ...
    };

    def new[K,V] () -> Dict[K,V] {
        # ...
    };
};

#
# Enums:
#

enum Color {
    rgba Tuple[U8,U8,U8,U8],
    hsva Tuple[U8,U8,U8,U8],
    name String,
    none
};


#
# Slices and Leas:
#

mod greeting {
    def new_cstr () -> CString {
        let len = 12;
        let buf = heap.alloc[Char](len);
        set 0 @ buf = 'h';
        set 1 @ buf = 'e';
        set 2 @ buf = 'l';
        set 3 @ buf = 'l';
        set 4 @ buf = 'o';
        set 5 @ buf = ' ';
        set 6 @ buf = 'w';
        set 7 @ buf = 'o';
        set 8 @ buf = 'r';
        set 9 @ buf = 'l';
        set 10 @ buf = 'd';
        set 11 @ buf = '\0';
        {ptr=memory, len=len}
    };
};

mod heap {
    def alloc [T] (len U64) -> T* {
        let ptr = malloc(len * sizeof[T]);
        buffer.new(ptr,len)
    };
};

#
# Lambdas, iterators, and for:
#

mod closed {

    def loops () -> Unit {
        let prime_limit = console.read_int[I32]("Enter a number >2 until which to search for primes: ");
        let prime_count = 1;
        
        for (iter 3 .. prime_limit step 2) do
        fun i -> {
            for (iter fac = 0; fac*fac < i; fac+2) do
            fun (j S32) -> {
                if i % 2 == 0 then {
                    set ^prime_count = prime_count+1;
                } else {
                    # do nothing
                }
            }
        };
    };

};
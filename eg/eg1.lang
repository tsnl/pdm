#
# Use the 'val' statement to construct and denote datatypes.
# - Note that names cannot be omitted in function patterns.
# - The arguments to this 'val' function are converted into a named tuple and returned.
# - Template args allowed.
#

val Pixel[t] (
    r: t,
    g: t,
    b: t
);

val Image[t] (
    name: string,
    size: (u16,u16),
    data: Buffer[Pixel[t]]
);

#
# Use the 'def' statement to define a function.
# The return type is always automatically inferred, but argument types must be provided.
#

def addPixel[t] (p: Pixel[t], q: Pixel[t]) = {
    Pixel[t] (
        p.r + q.r,
        p.g + q.g,
        p.b + q.b
    )
};
def mulPixel[t] (p: Pixel[t], s: t) = {
    Pixel[t] (
        s * p.r, 
        s * p.g, 
        s * p.b
    )
};

# Functions in value contexts are first-class.
# - lambda ::= '$' <pattern> <body>
# - currying can be implemented by chaining lambda bodies.
def addImage[t] (lt: Image[t], rt: Image[t]) = {
    test lt.size = rt.size else {
        "lt and rt are of different sizes."
    };

    Image[t] (
        name: fmt "({lt.name}+{rt.name})",
        size: lt.size,
        data: map(addPixel,zip(lt.data,rt.data))
    )
};

def mulImage[t] (i: Image[t], x: u8) = {
    let scalePixelByX = [p: Pixel] {mulPixel(p,x)};
    Image[t] (
        name: fmt "({x}*{i.name})", 
        size: i.size,
        data: map i.data scalePixelByX
    )
};

val Circle (radius: f32);

def circumference (circle: Circle) = {
    let tau = {
        let pi = 3.14159
        2*pi
    };
    tau * circle.radius
};

#
# Use the 'enum' statement to define a variant.
# Like 'val' statements, 'enum' statements accept patterns.
#

enum Color (
    rgba: (u8,u8,u8,u8),
    hsva: (u8,u8,u8,u8),
    name: String
);
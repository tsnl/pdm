# Each source file is composed of
# 1. (1) 'namespace' statement
# 2. (0 or more) 'typedef' or 'def' statements
#    - typedefs must begin with uppercase letters.
#    - all other IDs are assumed to be 'def' statements.

namespace eg1;

#
# Circles:
#

type Circle = {
    center: (F32,F32),
    radius: (F32)
};

def circumference (circle: Circle) = {
    let tau = {
        let pi = 3.14159;
        2*pi
    };
    tau * circle.radius
};

#
# Pixels (generics):
#

type Pixel [T] = {r:T,g:T,b:T};
type Image [T] = {name:String, size:(U32,U32), data:Buffer[Pixel[T]]};

def addPixel [T] (p: Pixel T, q: Pixel T) = {
    Pixel[T] (p.r+q.r, p.g+q.g, p.b+q.b)
};

def mulPixel [T] (p: Pixel T, s: T) = {
    Pixel[T] (s*p.r, s*p.g, s*p.b)
};

def addImage [T] (lt: Image T, rt: Image T) = Image[T] {
    with lt.size == rt.size;
    Image[T] {
        name: fmt "({lt.name}+{rt.name})",
        size: lt.size,
        data: map addPixel (zip lt.data rt.data)
    }
};

def mulImage [T] (i: Image T, x: U8) = Image[T] {
    let scalePixelByX = fun p => {
        mulPixel p x
    };
    Image[T] {
        name: fmt "({x}*{i.name})",
        size: i.size,
        data: map i.data scalePixelByX
    }
};

#
# Dicts (generics):
#

type Dict [K,V] = {
    # ...
};

def newDict [K,V] = (Dict K V) {
    # ...
};

#
# Enums:
#

enum Color = {
    rgba: (U8,U8,U8,U8),
    hsva: (U8,U8,U8,U8),
    name: String,
    none
};

# Enums: simple enough.

mod optional [T ANY] {

    Opt = enum {
        Some T,
        None
    };

};

mod rational {

    RationalData = {
       numerator Int32,
       denominator Int32
    };

    Rational = optional[RationalData]::Opt;

    rational = (numerator Int32, denominator Int32) -> Rational {
        if (denominator != 0) then {
            Rational::Some using {
                numerator = numerator,
                denominator = denominator
            };
        } else {
            Rational::None
        }
    };

    RationalBinOp = (Rational, Rational) -> Rational;

    apply = (x Rational, y Rational, f RationalBinOp) -> Rational {
        match (x) with {
            Some (vx) -> {
                match (y) with {
                    Some (vy) -> {
                        Rational::Some using f(vx,vy)
                    },
                    None -> {
                        Rational::None
                    }
                }
            },
            None -> {
                Rational::None
            }
        }
    };

    add_incorrectly = (x Q, y Q) -> Q {
        apply(x, y, (x Q, y Q) -> {
            numerator: (x.numerator + y.numerator),
            denominator: (x.denominator + y.denominator)
        })
    };

    # TODO: explore monad unwrapping
    # TODO: support 0-length enum values.
    # - Enum fields reference a constructor function or default value (even though TIDs)
    # - Each 'match' arm starts with a TID (for an enum branch), followed by an optional lpattern, followed by 'then', followed by paren_exp branch.
    # TODO: revert 'lambda' to lpattern without return-- need a short function notation...

};
# Waterfall modules

# The final component to a robust object system is a good namespace management system 
# to precisely import overloads, classes, and other useful symbols.

# Since selective imports risk breaking a type's class membership, we
# must import all symbols in a module into an ENCAPSULATED NAMESPACE.

# The 'import' statement declaratively loads a module for access by a fixed VID name.
# the expressions can be const stored elsewhere.
# Libraries are 'installed' to the filesystem to build to, though in the future, it may
# be possible to specify libraries via git/hg URI which the compiler will automatically
# install and cache.

import std from ("file/fs", "basic.lang");
import eg3 from ("file/fs", "eg3.lang");
import sdl from ("lib/fs", "pandemonium-sdl2");
import avx from ("lib/fs", "pandemonium-avx");

mod car {
    type Car = {
        name Text,
        price I32
    };
    def new (name Text, price I32) Car = {
        (name, price)
    };
};

mod level1 {
    mod damage {
        def wearAndTear (car ^&eg3.Car, dsec F32) Void = {
            let fancyScoreDamagePerSec = 1.2;
            set car->fancyScore = car->fancyScore - U32(fancyScoreDamagePerSec * dsec);
        };
    };
};

#
# ~'import'~ 'using' explicitly brings another module's symbols into this module's namespace.
# - optional '::' => import 1 symbol matching...; exactly like 'class' requirement
# - optional '*' suffix => match this and everything with this suffix
# thus, the ~3~ 2 options to import symbols, from coarsest to finest:
# - globbed name imports
# - whole name imports
# - ~class-requirement statements~
#

using std.deq.*;
using std.vec.Vec;

mod demo {

    import std.pi;
    import std.List;
    import std.Dict;

    import eg3.Vehicle;
    import eg3.newCarList;
    import eg3.newCarDict;
    import eg3.printVehicle :: Fn Car Unit;

    def test () := {
        let carList List[Vehicle] = newCarList();
        let v1 = (1.0,2.0,3.0,4.0);
        let v2 = (2.0,3.0,4.0,5.0);
        
        let result1 = avx.mul v1 v2;
        let result2 = avx.add v1 v2;
    };

};

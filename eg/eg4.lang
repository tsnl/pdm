# Waterfall modules

# The final component to a robust object system is a good namespace management system 
# to precisely import overloads, classes, and other useful symbols.

# Since selective imports risk breaking a type's class membership, we
# must import all symbols in a module into an ENCAPSULATED NAMESPACE.

# The 'module' statement declaratively loads a module for access under a VID name.

module std from "basic.lang" as "file/fs";
module eg3 from "eg3.lang" as "file/fs";
module sdl from "pandemonium-sdl2" as "lib/fs";
module avx from "pandemonium-avx" as "lib/fs";

def newCar (name: Text, price: I32) = eg3.Car {
    (name, price)
};

def wearAndTear (car: &eg3.Car, dsec: F32) = {
    let fancyScoreDamagePerSec = 1.2;
    set car.fancyScore = *car.fancyScore - U32(fancyScoreDamagePerSec * dsec);
};

#
# 'import' explicitly brings another module's symbols into this module's namespace.
# - optional '::' => import 1 symbol matching...; exactly like 'class' requirement
# - optional '*' suffix => match this and everything with this suffix
# thus, the 3 options to import symbols, from coarsest to finest:
# - whole name imports
# - globbed name imports
# - class-requirement statements
#

import std.pi;
import std.List;
import std.Dict;

import eg3.Vehicle;
import eg3.newCarList;
import eg3.newCarDict;
import eg3.printVehicle :: (Car)->();

import avx.operator_mul_*;
import avx.operator_add_*;

def test () = {
    let carList: List[Vehicle] = newCarList();
    let v1 = (1.0,2.0,3.0,4.0);
    let v2 = (2.0,3.0,4.0,5.0);
    let result1 = v1 * v2;  # operator overloading using imported generic operator_mul_*
    let result2 = v1 + v2;  # operator overloading using imported generic operator_add_*
};

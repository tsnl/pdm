# Changes:
# - change top module syntax: --- <Name> ---
# - use 'sub -< ... >-' for submodules.

# imports link one module at a time. No fuzzy matching.
import SDL2 from "https://github.com/tsnl/Fib.pd-package";

--- Shapes ---

Circle = {
    center Tuple[F32,F32],
    radius Tuple[F32]
};
circumference = fn (circle Circle) -> F32 {
    val tau = {
        val pi = 3.14159;
        2*pi
    };
    tau * circle.radius
};

--- Pixels ---

Pixel [T Any] = {
    r T,
    g T,
    b T
};
Image [T Any] = {
    name String,
    size Tuple[U32,U32],
    data Buffer[Pixel[T]]
};

add [T Any] = fn (p Pixel[T], q Pixel[T]) -> Pixel[T] {
    r: p.r + q.r,
    g: p.g + q.g, 
    b: p.b + q.b
};
multiply [T Any] = fn (p Pixel[T], s T) -> Pixel[T] {
    r: s * p.r, 
    g: s * p.g, 
    b: s * p.b
};

--- Image ---

add [T Any] = fn (lt Image[T], rt Image[T]) -> Image[T] {
    assert lt.size == rt.size;
    {
        name: fmt("({lt.name}+{rt.name})"),
        size: lt.size,
        data: map(addPixel, zip(lt.data,rt.data))
    }
};
multiply [T Any] = fn (i Image[T], x U8) -> Image[T] {
    name: fmt("({x}*{i.name})"),
    size: i.size,
    data: map(i.data, lambda (p Pixel[T]) {multiply(pixel,x)})
};

--- Dict ---

Dict [K,V Any] = {
    # ...
};

new [K,V Any] = fn () -> Dict[K,V] {
    # ...
};

#
# Enums
# - untagged unions are not supported in the language by default
# - for such operations, use `bitcast[]()` like LLVM
#

--- Events ---

Color
| Rgba Tuple[U8,U8,U8,U8]
| Hsva Tuple[U8,U8,U8,U8]
| Name String
| None
;

Fruit 
| Apple | Banana | Cherry | Durian | Fig | Grape
; 

Key
| Escape | F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10 | F11 | F12
| Tilde  | N1 | N2 | N3 | N4 | N5 | N6 | N7 | N8 | N9 | N0 | Minus | Equals | Backspace
| Tab       | Q | W | E | R | T | Y | U | I | O | P | LeftSquareBracket | RightSquareBracket | Backslash
| CapsLock  | A | S | D | F | G | H | J | K | L | Semicolon | SingleQuote | Return
| LeftShift | Z | X | C | V | B | N | M | Comma | Period | ForwardSlash | RightShift
| LeftCtrl  | LeftMeta | LeftAlt | RightAlt | RightMeta | RightCtrl |
| Up | Down | Left | Right
;

MouseButton
| Left
| Right
| Middle
;

ButtonMoveDirection
| Down
| Up
;

--- Greeting ---

new_cstr = fn () -> CString {
    val len = 12;
    val buf = heap.alloc(Char)[len];
    set buf->(0) = 'h';
    set buf->(1) = 'e';
    set buf->(2) = 'l';
    set buf->(3) = 'l';
    set buf->(4) = 'o';
    set buf->(5) = ' ';
    set buf->(6) = 'w';
    set buf->(7) = 'o';
    set buf->(8) = 'r';
    set buf->(9) = 'l';
    set buf->(10) = 'd';
    set buf->(11) = '\0';
    {ptr=memory, len=len}
};

--- Primes ---

driver = fn () {
    # val prime_limit = console.read_int[Int32]("Enter a number >2 until which to search for primes: ");
    val primes_until = count_primes_until(prime_limit);
    
}

count_primes_until = fn (primes_limit Int32) -> Int32 {
    var prime_count = 1;
    
    foreach (i: 3 .. prime_limit step 2) {
        var i_is_prime = true;
        for (fac = 0; fac*fac < i; fac+2) {
            if (i % fac == 0) then {
                set i_is_prime = false;
            };
        };
        if (i_is_prime) then {
            set prime_count = 1 + prime_count;
        };
    }
};

--- Submodules ---

sub S1 {
    hello = 0;
};

sub S2 [UInt UInts] {
    filter = fn (image Image[UInt]) -> Image {
        # ...
    };

    sub DoubleNested {
        hi = 0;
    };
};

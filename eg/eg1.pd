# Changes:
# - change top module syntax: --- mod <Name> ---
# - use 'sub -< ... >-' for submodules.

# imports link one module at a time. No fuzzy matching.
import "https://github.com/tsnl/Fib.pd-package" as "git/pd-package";

mod shapes {

    Circle = {
        center Tuple[F32,F32],
        radius Tuple[F32]
    };

    circumference = (circle Circle) -> F32 {
        val tau = {
            val pi = 3.14159;
            2*pi
        };
        tau * circle.radius
    };

};

mod pixels {

    Pixel [T Any] = {
        r T,
        g T,
        b T
    };
    Image [T Any] = {
        name String,
        size Tuple[U32,U32],
        data Buffer[Pixel[T]]
    };

    add [T Any] = fn (p Pixel[T], q Pixel[T]) -> Pixel[T] {
        r: p.r + q.r,
        g: p.g + q.g, 
        b: p.b + q.b
    };
    multiply [T Any] = fn (p Pixel[T], s T) -> Pixel[T] {
        r: s * p.r, 
        g: s * p.g, 
        b: s * p.b
    };

};

mod image {

    add [T Any] = fn (lt Image[T], rt Image[T]) -> Image[T] {
        assert lt.size == rt.size;
        {
            name: fmt("({lt.name}+{rt.name})"),
            size: lt.size,
            data: map(addPixel, zip(lt.data,rt.data))
        }
    };
    multiply [T Any] = fn (i Image[T], x U8) -> Image[T] {
        name: fmt("({x}*{i.name})"),
        size: i.size,
        data: map(i.data, lambda (p Pixel[T]) {multiply(pixel,x)})
    };

 };
 
 mod dict {

    Dict [K,V Any] = {
        # ...
    };

    new [K,V Any] = fn () -> Dict[K,V] {
        # ...
    };

    #
    # Enums
    # - untagged unions are not supported in the language by default
    # - for such operations, use `bitcast[]()` like LLVM
    #

};

mod events {

    Color = enum {
        Rgba {U8,U8,U8,U8},
        Hsva {U8,U8,U8,U8},
        Name String,
        None
    };

    Fruit = enum {
        Apple, Banana, Cherry, Durian, Fig, Grape
    };

    Key = enum {
        Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
        Tilde, N1, N2, N3, N4, N5, N6, N7, N8, N9, N0, Minus, Equals, Backspace,    | Tab       | Q | W | E | R | T | Y | U | I | O | P | LeftSquareBracket | RightSquareBracket | Backslash
        CapsLock, A, S, D, F, G, H, J, K, L, Semicolon, SingleQuote, Return,
        LeftShift, Z, X, C, V, B, N, M, Comma, Period, ForwardSlash, RightShift,
        LeftCtrl, LeftSuper, LeftAlt, RightAlt, RightSuper, RightCtrl,
        Up, Down, Left, Right
    };

    MouseButton = enum {
        Left,
        Right,
        Middle
    };

    ButtonMoveDirection = enum {
        Down,
        Up
    };

};

mod greeting {

    new_cstr = () -> CString {
        val len = 12;
        val buf = heap.alloc(Char)[len];
        set buf.(0) = 'h';
        set buf.(1) = 'e';
        set buf.(2) = 'l';
        set buf.(3) = 'l';
        set buf.(4) = 'o';
        set buf.(5) = ' ';
        set buf.(6) = 'w';
        set buf.(7) = 'o';
        set buf.(8) = 'r';
        set buf.(9) = 'l';
        set buf.(10) = 'd';
        set buf.(11) = '\0';
        {ptr=memory, len=len}
    };

};

mod Primes {

    driver = () -> Void {
        # val prime_limit = console.read_int[Int32]("Enter a number >2 until which to search for primes: ");
        val primes_until = count_primes_until(prime_limit);
        
    }

    # proposed feature: for loops:
    count_primes_until = (primes_limit Int32) -> Int32 {
        var prime_count = 1;
        
        for (i: 3 .. prime_limit step 2) {
            var i_is_prime = true;
            for (fac = 0; fac*fac < i; fac+2) {
                if (i % fac == 0) then {
                    set i_is_prime = false;
                };
            };
            if (i_is_prime) then {
                set prime_count = 1 + prime_count;
            };
        }
    };

 };
 
 mod submodules {

    mod S1 {
        hello = 0;
    };

    mod S2 [UInt UInts] {
        filter = (image Image[UInt]) -> Image {
            # ...
        };

        mod DoubleNested {
            hi = 0;
        };
    };

 };
 
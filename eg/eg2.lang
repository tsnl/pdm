# treat functions as type definitions

# Short function definitions: just return the argument.
# Type definitions are just function definitions.
# Template definitions are only supported for the top-level function definitions that cannot omit type specifiers.
# Capitalized functions are automatically exported.

Pixel[t]: (r,g,b t) {
    r: r, 
    g: g, 
    b: b
};

Pair[t]: (x,y t) {
    x: x,
    y: y
};

Image[t]: (name string, size Pair[u16], data Buffer[Pixel[t]]) {
    name: name,
    size: size,
    data: data
};

# Short definitions can be expanded to long definitions:
addPixel[t]: (p,q Pixel<t>) {
    Pixel[t] (
        p.r + q.r,
        p.g + q.g,
        p.b + q.b
    )
};
mulPixel[t]: (p Pixel[t], s t) -> {
    Pixel <t> (
        s * p.r,
        s * p.g,
        s * p.b
    )
};

# Functions in value contexts are first-class.
# In type contexts, functions are interpreted as types.
# To write a lambda, use the '->' operator in value contexts.
# To depict a function signature, use the `->` operator in type contexts.
addImage[t]: (i,j Image[t]) {
    check(i.size == j.size, "a and b are of different sizes.");
    name = f"({i.name}+{j.name})";
    size = i.size;
    data = map(addPixel, zip(i.data, j.data));
    Image<t>(name, size, data)
};
mulImage[t]: (i Image[t], x u8) {
    Image[t] (
        name: f"({x}*{i.name})", 
        size: i.size,
        data: map(
            pixel -> mulPixel(pixel, x), 
            i.data
        )
    )
};

#
# Zip (assuming Iterable, next)
#

zip[t]: (a Iterable[t], b Iterable[t]) {
    match (next(a), next(b)) {
        (x Some[t], y Some[t]) {
            Some[t](Pair[t](x, y))
        };
        (_) {
            None
        };
    }
};

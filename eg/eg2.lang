# treat functions as type definitions

# Short function definitions: just return the argument.
# Type definitions are just function definitions.

Pixel <t> (
    r: t,
    g: t,
    b: t
);
Pair <t> (
    x: x, 
    y: y
);
Image <t> (
    name: string, 
    size: Pair<u16>,
    data: Buffer<Pixel<t>>
);

# Short definitions can be expanded to long definitions:
addPixel <t> (p: Pixel<t>, q: Pixel<t>) = {
    Pixel <t> (
        p.r + q.r,
        p.g + q.g,
        p.b + q.b
    )
};
mulPixel <t> (p: Pixel<t>, s: t) = {
    Pixel <t> (
        s * p.r,
        s * p.g,
        s * p.b
    )
};

# Functions in value contexts are first-class.
# In type contexts, functions are interpreted as types.
# To write a lambda, use the '->' operator in value contexts.
# To depict a function signature, use the `->` operator in type contexts.
addImage <t> (i: Image<t>, j: Image<t>) = {
    do assert(i.size == j.size, "a and b are of different sizes.");
    name = f"({i.name}+{j.name})";
    size = i.size;
    data = map(addPixel, zip(i.data, j.data));
    Image<t>(name, size, data)
};
mulImage <t> (i: Image<t>, x: u8) = {
    name = f"({x}*{i.name})";
    size = i.size;
    data = map(pixel -> mulPixel(pixel, x), i.data);
    Image<t>(name, size, data)
};

#
# Zip (assuming Iterable, next)
#

zip <t> (a: Iterable<t>, b: Iterable<t>) = {
    match (next(a), next(b)) {
        (x: Some<t>, y: Some<t>) -> Some((x, y));
        _ -> None;
    }
};

#
# Enums are similar to structs, except with multiple short definitions
#

Opt <t> = [
    Some (value: t),
    None
];

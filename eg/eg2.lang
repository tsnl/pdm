# treat functions as type definitions

# Short function definitions: just return the argument.
# Type definitions are just function definitions.
# Template definitions are only supported for the top-level function definitions that cannot omit type specifiers.
# Capitalized functions are automatically exported.

Pixel <t> = (r: t, g: t, b: t) -> {
    r: r, 
    g: g, 
    b: b
};

Pair <t> = (x: x, y: y) -> {
    x: x,
    y: y
};

Image <t> = (name: string, size: Pair<u16>, data: Buffer<Pixel<t>>) -> {
    name: name,
    size: size,
    data: data
};

# Short definitions can be expanded to long definitions:
addPixel <t> = (p: Pixel<t>, q: Pixel<t>) -> {
    return Pixel <t> (
        p.r + q.r,
        p.g + q.g,
        p.b + q.b
    );
};
mulPixel <t> = (p: Pixel<t>, s: t) -> {
    return Pixel <t> (
        s * p.r,
        s * p.g,
        s * p.b
    );
};

# Functions in value contexts are first-class.
# In type contexts, functions are interpreted as types.
# To write a lambda, use the '->' operator in value contexts.
# To depict a function signature, use the `->` operator in type contexts.
addImage <t> = (i: Image<t>, j: Image<t>) -> {
    check(i.size == j.size, "a and b are of different sizes.");
    name = f"({i.name}+{j.name})";
    size = i.size;
    data = map(addPixel, zip(i.data, j.data));
    return Image<t>(name, size, data);
};
mulImage <t> = (i: Image<t>, x: u8) -> {
    return Image<t> (
        name: f"({x}*{i.name})", 
        size: i.size,
        data: map(
            pixel -> mulPixel(pixel, x), 
            i.data
        )
    );
};

#
# Zip (assuming Iterable, next)
#

zip <t> = (a: Iterable<t>, b: Iterable<t>) -> {
    return match (next(a), next(b)) {
        (x: Some<t>, y: Some<t>) -> Some((x, y));
        (_) -> None;
    };
};

#
# Enums are produced by returning from different branches of a function.
#

Opt <t> = (some: u1, value: t) -> {
    if some {
        return some = value;
    } else {
        return none = ();
    };
};
Some <t> = (value: t) -> {
    return Opt<t>(1, value);
};
None <t> = () -> {
    return Opt<t>(0, value);
};

# Waterfall modules

# The final component to a robust object system is a good namespace management system 
# to precisely import overloads, classes, and other useful symbols.

# Since selective imports risk breaking a type's class membership, we
# must import all symbols in a module into an ENCAPSULATED NAMESPACE.

# The 'import' statement declaratively loads a module for access by a fixed VID name.
# - the arg expressions can be const stored elsewhere; e.g. const t = "file/fs"; import t from "./a.pdm" type t
# Libraries are 'installed' to the filesystem to build to, though in the future, it may
# be possible to specify libraries via git/hg URI which the compiler will automatically
# install and cache.

import std from "basic.pdm" type "fs/file";
import eg3 from "eg3.pdm"   type "fs/file";

mod car {
    type Car = {
        name Text,
        price I32
    };
    fn new (name Text, price I32) -> Car = {
        (name, price)
    };
};

mod level1 {
    mod damage {
        fn wearAndTear (car ^&eg3.Car, dsec F32) = {
            let fancyScoreDamagePerSec = 1.2;
            set car->fancyScore = car->fancyScore - convert[U32](fancyScoreDamagePerSec * dsec);
        };
    };
};

#
# 'using' explicitly brings another module's symbols into this module's namespace.
# - optional '*' suffix => match this and everything with this suffix
# thus, the 2 options to import symbols, from coarsest to finest:
# - globbed name imports
# - whole name imports
#

using std.deq.*;
using std.vec.Vec;

mod demo {
    using std.pi;
    using std.List;
    using std.Dict;

    using eg3.Vehicle;
    using eg3.newCarList;
    using eg3.newCarDict;
    using eg3.printVehicle :: Fn Car Unit;

    fn test () = {
        let carList List[Vehicle] = newCarList();
        let v1 = (1.0,2.0,3.0,4.0);
        let v2 = (2.0,3.0,4.0,5.0);
        
        let result1 = avx.mul(v1,v2);
        let result2 = avx.add(v1,v2);
    };

};

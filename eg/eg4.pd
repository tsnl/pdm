# Waterfall modules

# The final component to a robust object system is a good namespace management system 
# to precisely import overloads, classes, and other useful symbols.

# Since selective imports risk breaking a type's class membership, we
# must import all symbols in a module into an ENCAPSULATED NAMESPACE.

# The 'import' statement declaratively loads a module for access by a fixed VID name.
# - the arg expressions can be const stored elsewhere; e.g. const t = "file/fs"; import t from "./a.pdm" type t
# Libraries are 'installed' to the filesystem to build to, though in the future, it may
# be possible to specify libraries via git/hg URI which the compiler will automatically
# install and cache.

import Deque from "basic.pd" type "script/fs";
import Vector from "basic.pd" type "script/fs";
import Eg3 from "eg3.pd"   type "script/fs";

mod Vehicle {

    Car = {
        name Text,
        price Int32
    };
    new = fn (name Text, price Int32) -> Car {
        (name, price)
    };

}

mod Level1 {

    sub damage {
        wearAndTear = fn (inout car eg3.Car, dsec Float32) {
            val fancyScoreDamagePerSec = 1.2;
            set car.fancyScore = car.fancyScore - convert[UInt32](fancyScoreDamagePerSec * dsec);
        };
    };

}